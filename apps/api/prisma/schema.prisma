// F-Zero 99 Matchmaking Site - Prisma Schema
// NestJS v11 + PostgreSQL + Prisma 6
// Complete redesign - 2025
// Updated: Step 1, Step 2 & Step 3 schema improvements applied
// Step 3: Lobby → Match, Match → Game rename

generator client {
  provider   = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum UserRole {
  PLAYER
  MODERATOR
  ADMIN
}

enum UserStatus {
  ACTIVE
  WARNED
  SUSPENDED // 一時停止（期限付き）
  BANNED // 永久BAN
  DELETED // ソフトデリート用
}

// EventType は削除 - EventCategory で判別可能

enum EventCategory {
  GP // 常設シーズン、GPレート計算
  CLASSIC // 常設シーズン、CLASSICレート計算
  TOURNAMENT // 大会、レート計算なし
}

enum InGameMode {
  GRAND_PRIX
  MINI_PRIX
  TEAM_BATTLE
  CLASSIC_MINI_PRIX
  PRO
  CLASSIC
  NINETY_NINE
}

enum League {
  // GPモード用
  KNIGHT
  QUEEN
  KING
  ACE
  MIRROR_KNIGHT
  MIRROR_QUEEN
  MIRROR_KING
  MIRROR_ACE

  // classicモード用
  CLASSIC_MINI
}

enum MatchStatus {
  WAITING // 開始前
  IN_PROGRESS // 進行中
  COMPLETED // 完了
  FINALIZED // 確定済み（スクショ選択済み）
  CANCELLED // キャンセル
}

enum ResultStatus {
  PENDING // 未入力（deadline前）
  SUBMITTED // 提出済
  UNSUBMITTED // 未提出（deadline後に自動設定）
  DISPUTED // 異議審査中
  INVALIDATED // 無効化（不正等）
}

enum ResultReliability {
  VERIFIED // スクショまたは配信で確認済み
  PARTIAL // 部分的に確認
  UNVERIFIED // 未確認（自己申告のみ）
  DISPUTED // 異議申し立て中
}

enum StreamPlatform {
  YOUTUBE
  TWITCH
}

enum BanSeverity {
  WARNING
  TEMP_BAN
  PERM_BAN
}

enum DisputeStatus {
  PENDING
  INVESTIGATING
  ACCEPTED
  REJECTED
  RESOLVED
}

enum PenaltyType {
  FALSE_REPORT // 虚偽報告
  NO_SUBMISSION // 無報告
  LATE_SUBMISSION // 遅延報告
}

// ==================== USERS ====================

model User {
  id                       Int       @id @default(autoincrement())
  discordId                String    @unique
  username                 String
  displayName              String?   @db.VarChar(10)
  displayNameLastChangedAt DateTime?
  avatarHash               String?
  email                    String?   @unique

  role           UserRole   @default(PLAYER)
  status         UserStatus @default(ACTIVE)
  suspendedUntil DateTime?  // SUSPENDED時の解除日時
  deletedAt      DateTime?  // ソフトデリート用

  // テスト用フラグ
  isFake Boolean @default(false)

  // 配信URL
  youtubeUrl String?
  twitchUrl  String?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // ペナルティシステム
  penaltyPoints Int @default(0)

  // 信頼スコア（将来用）
  trustScore Int @default(100)

  // リレーション
  seasonStats        UserSeasonStats[]
  matchParticipants  MatchParticipant[]
  gameParticipants   GameParticipant[]
  createdEvents      Event[]                    @relation("EventCreator")
  createdMatches     Match[]                    @relation("MatchCreator")
  splitVotes         SplitVote[]
  banHistory         BanRecord[]                @relation("BanTarget")
  moderatorActions   BanRecord[]                @relation("ModeratorActions")
  penalties          PenaltyRecord[]
  pushSubscriptions    PushSubscription[]
  disputes             ResultDispute[]            @relation("DisputeReporter")
  disputeTargets       ResultDispute[]            @relation("DisputeTarget")
  loginHistory         UserLoginHistory[]
  submittedScreenshots GameScreenshotSubmission[] @relation("SubmittedScreenshots")
  selectedScreenshots  ResultScreenshot[]         @relation("SelectedScreenshots")
  screenshotSelections ResultScreenshot[]         @relation("ScreenshotSelections")
  ratingHistories      RatingHistory[]            @relation("RatingHistory")

  @@index([discordId])
  @@index([displayName])
  @@index([status])
  @@map("users")
}


// ==================== USER SEASON STATS (シーズン別レート・統計管理) ====================

model UserSeasonStats {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  seasonId Int
  season   Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  // レート
  internalRating    Float @default(2750) // 内部レート
  displayRating     Int   @default(0)    // 表示レート（0から始まり収束）
  convergencePoints Float @default(0)    // 収束ポイント（20で完全収束）
  seasonHighRating  Int   @default(0)    // displayRatingの最高値

  // 統計（非正規化 - リーダーボード用）
  totalMatches    Int @default(0) // 参加ゲーム数
  firstPlaces     Int @default(0) // 1位回数
  secondPlaces    Int @default(0) // 2位回数
  thirdPlaces     Int @default(0) // 3位回数
  survivedCount   Int @default(0) // 生き残り回数（脱落せず完走）
  assistUsedCount Int @default(0) // アシスト使用回数

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, seasonId])
  @@index([seasonId, displayRating])
  @@index([userId])
  @@map("user_season_stats")
}

// ==================== RATING HISTORY ====================

model RatingHistory {
  id      Int   @id @default(autoincrement())
  userId  Int
  user    User  @relation("RatingHistory", fields: [userId], references: [id], onDelete: Cascade)
  matchId Int
  match   Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  internalRating Float // この試合後の内部レート
  displayRating  Int   // この試合後の表示レート

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([matchId])
  @@map("rating_histories")
}

// ==================== USER LOGIN TRACKING ====================

model UserLoginHistory {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  ipAddress String
  ipVersion String? // IPv4 or IPv6
  userAgent String? @db.Text

  // Optional geolocation data
  country  String?
  city     String?
  timezone String?

  // Proxy/VPN detection
  isVpn   Boolean @default(false)
  isProxy Boolean @default(false)
  isTor   Boolean @default(false)

  // Login context
  loginMethod String  @default("discord")
  deviceType  String?
  browser     String?
  os          String?

  loginAt DateTime @default(now())

  @@index([userId, ipAddress])
  @@index([ipAddress])
  @@index([loginAt])
  @@map("user_login_history")
}

// ==================== EVENT / SEASON / TOURNAMENT ====================

model Event {
  id          Int           @id @default(autoincrement())
  category    EventCategory // GP, CLASSIC, or TOURNAMENT
  name        String // "CLASSIC", "GP", "John Cup", "Winter Cup 2025"
  description String?

  createdBy     Int?
  createdByUser User?    @relation("EventCreator", fields: [createdBy], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // 1:多 リレーション
  seasons Season[]

  @@index([category])
  @@map("events")
}

model Season {
  id      Int   @id @default(autoincrement())
  eventId Int
  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  seasonNumber Int
  startDate    DateTime
  endDate      DateTime?
  isActive     Boolean   @default(false)
  description  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // リレーション
  tournamentConfig TournamentConfig? // 1:1 (Tournament の場合のみ)
  matches          Match[] // 1:多
  userSeasonStats  UserSeasonStats[]

  @@unique([eventId, seasonNumber])
  @@index([eventId])
  @@index([isActive])
  @@map("seasons")
}

model TournamentConfig {
  id       Int    @id @default(autoincrement())
  seasonId Int    @unique
  season   Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  // 大会形式
  totalRounds Int
  leagues     Json // ["KNIGHT", "QUEEN", "ACE"]

  // 参加人数
  minPlayers Int @default(40)
  maxPlayers Int @default(99)

  // スケジュール
  registrationStart DateTime
  registrationEnd   DateTime

  // 大会設定
  intervalMinutes   Int @default(10)
  editWindowMinutes Int @default(10)
  disputeDays       Int @default(7)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("tournament_configs")
}

// ==================== MATCH ====================

model Match {
  id Int @id @default(autoincrement())

  // Season に紐づく（Event → Season → Match）
  seasonId Int
  season   Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  // gameMode は削除 - Season → Event.category で取得可能
  // leagueType は削除 - Game毎に異なる可能性があるためGame側で管理
  matchNumber Int

  status MatchStatus @default(WAITING)

  // currentPlayers は削除 - MatchParticipant の COUNT で取得
  minPlayers Int @default(4)
  maxPlayers Int @default(20)

  scheduledStart DateTime
  actualStart    DateTime?
  deadline       DateTime   // スコア提出期限（この時刻で自動完了）

  // 管理用
  createdBy     Int?
  createdByUser User?   @relation("MatchCreator", fields: [createdBy], references: [id])
  notes         String?

  // MMR制限（オプション）
  minMmr Int?
  maxMmr Int?

  createdAt DateTime @default(now())

  // リレーション
  participants    MatchParticipant[]
  games           Game[]
  ratingHistories RatingHistory[]

  @@unique([seasonId, matchNumber])
  @@index([status])
  @@index([seasonId])
  @@index([scheduledStart])
  @@map("matches")
}

model MatchParticipant {
  id      Int   @id @default(autoincrement())
  matchId Int
  match   Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  userId  Int
  user    User  @relation(fields: [userId], references: [id])

  joinedAt     DateTime @default(now())
  hasWithdrawn Boolean  @default(false)

  // TOURNAMENT専用（累計成績）
  totalPoints   Int       @default(0)
  finalRank     Int?
  lastUpdatedAt DateTime?

  withdrawnAt DateTime?

  // Relations
  streams MatchStream[]

  @@unique([matchId, userId])
  @@index([matchId])
  @@index([userId])
  @@index([matchId, totalPoints])
  @@index([matchId, hasWithdrawn])
  @@map("match_participants")
}

// ==================== GAME ====================

model Game {
  id      Int   @id @default(autoincrement())
  matchId Int
  match   Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  gameNumber Int // 1, 2, 3... (マッチ内のゲーム番号)

  inGameMode InGameMode // F-Zero 99 のゲーム内モード
  leagueType League

  // パスコード管理
  passcode            String    @db.VarChar(4)
  passcodePublishedAt DateTime?
  passcodeVersion     Int       @default(1)

  // totalPlayers は削除 - GameParticipant の COUNT で取得

  // CLASSIC用: 各レースのコース (例: ["Mute City I", "Big Blue", "Sand Ocean"])
  tracks Json?

  // 結果の信頼度
  resultReliability       ResultReliability @default(UNVERIFIED)
  reliabilityReason       String?
  hasFirstPlaceScreenshot Boolean           @default(false)
  hasStreamEvidence       Boolean           @default(false)
  verifiedAt              DateTime?
  verifiedBy              Int?

  startedAt DateTime?

  // リレーション
  participants         GameParticipant[]
  splitVotes           SplitVote[]
  submittedScreenshots GameScreenshotSubmission[] @relation("SubmittedScreenshots")
  screenshot           ResultScreenshot?
  disputes             ResultDispute[]

  @@unique([matchId, gameNumber])
  @@index([inGameMode])
  @@index([passcode])
  @@index([matchId])
  @@index([startedAt])
  @@map("games")
}

model GameParticipant {
  id     Int  @id @default(autoincrement())
  gameId Int
  game   Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId Int
  user   User @relation(fields: [userId], references: [id])

  // ゲーム参加時に決定（レース間で変更不可）
  machine       String
  assistEnabled Boolean @default(false)

  // 結果ステータス
  status ResultStatus @default(PENDING)

  // スコア提出
  submittedAt DateTime?

  // CLASSIC用: 合計スコアとランクアウトしたレース番号
  totalScore       Int? // 全レースのポイント合計
  eliminatedAtRace Int? // ランクアウトしたレース番号（null=全レース完走）

  // 各レースの結果
  raceResults RaceResult[]

  @@unique([gameId, userId])
  @@index([gameId])
  @@index([userId])
  @@index([status])
  @@map("game_participants")
}

model RaceResult {
  id                Int             @id @default(autoincrement())
  gameParticipantId Int
  gameParticipant   GameParticipant @relation(fields: [gameParticipantId], references: [id], onDelete: Cascade)

  raceNumber    Int      // 1-5 (GRAND_PRIX) or 1 (単発モード)
  position      Int?     // このレースの順位
  points        Int?     // このレースのポイント
  isEliminated  Boolean  @default(false) // クラッシュアウト/ランクアウトで脱落

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([gameParticipantId, raceNumber])
  @@index([gameParticipantId])
  @@map("race_results")
}

model MatchStream {
  id                 Int              @id @default(autoincrement())
  matchParticipantId Int
  matchParticipant   MatchParticipant @relation(fields: [matchParticipantId], references: [id], onDelete: Cascade)

  platform  StreamPlatform
  streamUrl String

  isLive       Boolean @default(false)
  thumbnailUrl String?
  viewerCount  Int?
  streamTitle  String?

  lastCheckedAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([matchParticipantId, platform])
  @@index([matchParticipantId])
  @@index([lastCheckedAt])
  @@map("match_streams")
}

model SplitVote {
  id     Int  @id @default(autoincrement())
  gameId Int
  game   Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId Int
  user   User @relation(fields: [userId], references: [id])

  passcodeVersion Int // どのパスコードバージョンに対する投票か
  votedAt         DateTime @default(now())

  @@unique([gameId, userId, passcodeVersion])
  @@index([gameId, passcodeVersion])
  @@map("split_votes")
}

// 一時提出（複数可能）
model GameScreenshotSubmission {
  id     Int  @id @default(autoincrement())
  gameId Int
  game   Game @relation("SubmittedScreenshots", fields: [gameId], references: [id], onDelete: Cascade)

  userId Int
  user   User @relation("SubmittedScreenshots", fields: [userId], references: [id])

  imageUrl String

  isSelected Boolean   @default(false)
  deletedAt  DateTime?

  uploadedAt DateTime @default(now())

  @@index([gameId, uploadedAt])
  @@index([isSelected, uploadedAt])
  @@map("game_screenshot_submissions")
}

// 管理者が選んだ正式版（1ゲーム1枚）
model ResultScreenshot {
  id     Int  @id @default(autoincrement())
  gameId Int  @unique
  game   Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  imageUrl String

  userId Int
  user   User @relation("SelectedScreenshots", fields: [userId], references: [id])

  selectedBy Int
  selector   User     @relation("ScreenshotSelections", fields: [selectedBy], references: [id])
  selectedAt DateTime @default(now())

  @@map("result_screenshots")
}

model ResultDispute {
  id     Int  @id @default(autoincrement())
  gameId Int
  game   Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  reporterId   Int
  reporter     User @relation("DisputeReporter", fields: [reporterId], references: [id])
  targetUserId Int
  targetUser   User @relation("DisputeTarget", fields: [targetUserId], references: [id])

  claimedPoints Int
  evidenceUrl   String
  reason        String @db.Text

  status     DisputeStatus @default(PENDING)
  resolution String?       @db.Text
  resolvedBy Int?
  resolvedAt DateTime?

  createdAt DateTime @default(now())

  @@index([gameId])
  @@index([status])
  @@index([createdAt])
  @@map("result_disputes")
}


// ==================== MODERATION ====================

model BanRecord {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation("BanTarget", fields: [userId], references: [id])

  action      String
  severity    BanSeverity
  reason      String
  description String?     @db.Text
  evidence    Json?

  moderatorId Int
  moderator   User @relation("ModeratorActions", fields: [moderatorId], references: [id])

  createdAt DateTime  @default(now())
  expiresAt DateTime?

  targetBanId Int?

  @@index([userId, createdAt(sort: Desc)])
  @@index([moderatorId])
  @@index([expiresAt])
  @@map("ban_records")
}


model PenaltyRecord {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id])

  gameId    Int?
  disputeId Int?

  type   PenaltyType
  points Int
  reason String

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@map("penalty_records")
}


// ==================== PUSH NOTIFICATIONS ====================

model PushSubscription {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  endpoint String
  p256dh   String
  auth     String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, endpoint])
  @@index([userId])
  @@map("push_subscriptions")
}
